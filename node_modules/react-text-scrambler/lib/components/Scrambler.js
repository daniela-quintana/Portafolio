"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = require("prop-types");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Scrambler = function (_React$Component) {
    _inherits(Scrambler, _React$Component);

    function Scrambler(props) {
        _classCallCheck(this, Scrambler);

        var _this = _possibleConstructorReturn(this, (Scrambler.__proto__ || Object.getPrototypeOf(Scrambler)).call(this, props));

        _this.state = {
            // display state will be completely removed later on?
            display: "",
            components: []
        };


        _this.updateFrame = _this.updateFrame.bind(_this);
        _this.scrambling = true;
        return _this;
    }

    _createClass(Scrambler, [{
        key: "getNextComponent",
        value: function getNextComponent(mode, str, key) {
            var Wrap = this.props.wrap && mode ? this.props.wrap : _react2.default.Fragment;

            return _react2.default.createElement(
                Wrap,
                { key: key },
                str
            );
        }
    }, {
        key: "startScrambling",
        value: function startScrambling(end, start) {
            var renderIn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;

            this.queue = [];
            end = end || "";

            // This would be provided by a parent component "Cycler"
            var lastScrambled = start || "";
            var longer = lastScrambled.length > end.length ? lastScrambled.length : end.length;
            var maxFrames = 60 * (renderIn / 1000);

            for (var i = 0, lastStartFrame = 0, dec = maxFrames; i < longer; i++) {
                var frames = maxFrames / longer;
                var humanLikeTime = lastScrambled.length < end.length ? lastStartFrame + Math.floor(Math.random() * frames * 0.9) : dec - Math.floor(Math.random() * frames * 0.9);

                var oldCharacter = lastScrambled[i] || "";
                var newCharacter = end[i] || "";

                // Renaming prop for "typing effect" to typewriter.
                // REMOVAL of 'humanLike' in v2.0.0
                var startTransformation = this.props.humanLike || this.props.typewriter ? humanLikeTime : Math.floor(Math.random() * maxFrames * 0.4);
                var transformationDuration = Math.floor(Math.random() * (maxFrames - startTransformation));
                var endTransformation = transformationDuration + startTransformation;

                dec = startTransformation;
                lastStartFrame = startTransformation;
                this.queue.push({
                    oldCharacter: oldCharacter,
                    newCharacter: newCharacter,
                    startTransformation: startTransformation,
                    endTransformation: endTransformation });
            }

            cancelAnimationFrame(this.renderFrame);
            this.updateFrame();
        }
    }, {
        key: "updateFrame",
        value: function updateFrame() {
            var _this2 = this;

            var charactersProcessed = 0;
            var nextDisplay = "";
            var character = void 0;

            var renderComponents = [];
            var stringBuilder = "";
            var mode = false;

            this.queue = this.queue.map(function (process, i) {
                // Removal of humanLike in v2.0.0
                var oldCharacter = process.oldCharacter,
                    newCharacter = process.newCharacter,
                    startTransformation = process.startTransformation,
                    endTransformation = process.endTransformation,
                    scrambleChar = process.scrambleChar;
                var _props = _this2.props,
                    humanLike = _props.humanLike,
                    typewriter = _props.typewriter;


                var append = oldCharacter;
                var returnThis = process;
                var modifyMode = false;

                if ((humanLike || typewriter) && _this2.frame > startTransformation) {
                    append = newCharacter;
                } else if (_this2.frame < startTransformation) {
                    append = oldCharacter;
                } else if (_this2.frame > endTransformation) {
                    append = newCharacter;
                    charactersProcessed++;
                } else if (scrambleChar) {
                    append = scrambleChar;
                    modifyMode = true;
                } else if (!humanLike && Math.random() < 0.05) {
                    character = _this2.randomCharacter();
                    append = character;
                    modifyMode = true;

                    returnThis = Object.assign({}, process, { scrambleChar: character });
                } else {
                    append = oldCharacter;
                }

                // If modes are equal, just append to the builder.
                // Otherwise, push the built string onto the render queue and flip the mode.
                if (modifyMode !== mode) {
                    renderComponents.push(_this2.getNextComponent(mode, stringBuilder, renderComponents.length));

                    stringBuilder = "" + append;
                    mode = !mode;
                } else {
                    stringBuilder += append;
                }

                nextDisplay += append;

                return returnThis;
            });

            if (stringBuilder !== "") {
                renderComponents.push(this.getNextComponent(mode, stringBuilder, renderComponents.length));
            }

            if (!this.scrambling) {
                // Prevent unsafe frame updates
                cancelAnimationFrame(this.renderFrame);
            } else {
                this.setState({ display: nextDisplay, components: renderComponents });

                if (charactersProcessed < this.queue.length) {
                    this.renderFrame = requestAnimationFrame(this.updateFrame);
                    this.frame++;
                } else {
                    // this.doneScrambling();
                }
            }
        }
    }, {
        key: "doneScrambling",
        value: function doneScrambling() {
            var onScrambleDone = this.props.onScrambleDone;


            if (typeof onScrambleDone === "function") {
                onScrambleDone(this.state.display);
            }
        }
    }, {
        key: "randomCharacter",
        value: function randomCharacter() {
            return this.characters[Math.floor(Math.random() * this.characters.length)];
        }
    }, {
        key: "getScrambleText",
        value: function getScrambleText(props) {
            var text = props.text,
                children = props.children;


            if (typeof text === "string") {
                return text;
            } else if (typeof children === "string") {
                return children;
            }

            return "No string was provided to the text prop!";
        }
    }, {
        key: "componentWillReceiveProps",
        value: function componentWillReceiveProps(nextProps) {
            if (this.props.static) {
                return;
            }

            // If new text is passed (possibly from a setState in the parent component),
            // restart scrambling.
            this.frame = 0;
            this.startScrambling(this.getScrambleText(nextProps), nextProps.changeFrom, nextProps.renderIn);
        }
    }, {
        key: "componentDidMount",
        value: function componentDidMount() {
            if (this.props.static) {
                return;
            }

            var _props2 = this.props,
                duration = _props2.duration,
                renderIn = _props2.renderIn,
                characters = _props2.characters;

            var scramble = this.getScrambleText(this.props);

            this.characters = characters;
            this.scrambling = true;

            this.frame = 0;
            this.startScrambling(scramble, "", duration || renderIn);
        }
    }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
            this.scrambling = false;
        }
    }, {
        key: "render",
        value: function render() {
            if (this.props.static) {
                return this.props.text;
            }

            return this.props.deprecatedFeatures ? this.state.display : this.state.components;
        }
    }]);

    return Scrambler;
}(_react2.default.Component);

Scrambler.propTypes = {
    text: _propTypes2.default.string,
    wrap: _propTypes2.default.func,
    duration: _propTypes2.default.number,
    renderIn: _propTypes2.default.number,
    humanLike: _propTypes2.default.bool,
    typewriter: _propTypes2.default.bool,
    changeFrom: _propTypes2.default.string,
    startDelay: _propTypes2.default.number,
    static: _propTypes2.default.bool,
    characters: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.arrayOf(_propTypes2.default.string)]),
    deprecatedFeatures: _propTypes2.default.bool,
    onScrambleDone: _propTypes2.default.func
};
Scrambler.defaultProps = {
    duration: 3000,
    renderIn: 3000,
    humanLike: false,
    typewriter: false,
    startDelay: 0,
    characters: "+/\\_-"
};
exports.default = Scrambler;